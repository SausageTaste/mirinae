#version 450

#include "../utils/konst.glsl"

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (binding = 0, rgba8) uniform writeonly image2D out_image;

layout(set = 0, binding = 1) uniform sampler2D u_noise0;
layout(set = 0, binding = 2) uniform sampler2D u_noise1;
layout(set = 0, binding = 3) uniform sampler2D u_noise2;
layout(set = 0, binding = 4) uniform sampler2D u_noise3;


layout (push_constant) uniform U_OceanTildeHPushConst {
    float time;
} u_pc;

const int N = 256;
const int L = 100;
const float A = 500000;
const float wind_speed = 40;
const vec2 wind_direc = vec2(1, 1);


vec4 gauseRnd() {
    const ivec2 tex_coord = ivec2(gl_GlobalInvocationID.xy);

    const float noise0 = clamp(texelFetch(u_noise0, tex_coord, 0).r, 0.001, 1.0);
    const float noise1 = clamp(texelFetch(u_noise1, tex_coord, 0).r, 0.001, 1.0);
    const float noise2 = clamp(texelFetch(u_noise2, tex_coord, 0).r, 0.001, 1.0);
    const float noise3 = clamp(texelFetch(u_noise3, tex_coord, 0).r, 0.001, 1.0);

    const float u0 = 2.0 * PI * noise0;
    const float v0 = sqrt(-2.0 * log(noise1));
    const float u1 = 2.0 * PI * noise2;
    const float v1 = sqrt(-2.0 * log(noise3));

    return vec4(v0 * cos(u0), v0 * sin(u0), v1 * cos(u1), v1 * sin(u1));
}


void main() {
    const vec2 x = vec2(gl_GlobalInvocationID.xy) - float(N) * 0.5;
    const vec2 k = x * 2.0 * PI / float(L);

    const float L_ = (wind_speed * wind_speed) / GRAVITY_EARTH;
    float mag = length(k);
    if (mag < 0.00001)
        mag = 0.00001;
    const float mgSq = mag * mag;
    const float l2 = L_ * L_ * 0.001 * 0.001;

    const float h0k = sqrt((A / (mgSq * mgSq))
        * pow(dot(normalize(k), normalize(wind_direc)), 2)
        * pow(dot(normalize(k), normalize(wind_direc)), 2)
        * pow(dot(normalize(k), normalize(wind_direc)), 2)
        * exp(-(1.0 / (mgSq * L_ * L_)))
        * exp(-mgSq * l2)) / sqrt(2.0);

    const float h0minusk = sqrt((A / (mgSq * mgSq))
        * pow(dot(normalize(-k), normalize(wind_direc)), 2)
        * pow(dot(normalize(-k), normalize(wind_direc)), 2)
        * pow(dot(normalize(-k), normalize(wind_direc)), 2)
        * exp(-(1.0 / (mgSq * L_ * L_)))
        * exp(-mgSq * l2)) / sqrt(2.0);

    const vec4 gause_random = gauseRnd();
    const vec2 h0k_vec = gause_random.xy * h0k;
    const vec2 h0minusk_vec = gause_random.zw * h0minusk;

    const ivec2 global_idx = ivec2(gl_GlobalInvocationID.xy);
    imageStore(out_image, global_idx, vec4(h0k_vec, h0minusk_vec));
}
