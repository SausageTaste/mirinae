#version 450

#define MULTISCATAPPROX_ENABLED 1

#include "../utils/konst.glsl"
#include "data.glsl"
#include "integrate.glsl"

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout (binding = 0, rgba16f) uniform writeonly image3D out_image;

layout (set = 0, binding = 1) uniform sampler2D u_trans_lut;
layout (set = 0, binding = 2) uniform sampler2D u_multi_scat;

layout (push_constant) uniform U_AtmosCamVolPushConst {
    mat4 pv_inv;
    mat4 proj_inv;
    mat4 view_inv;
    vec4 sun_direction;
    vec4 view_pos;
} u_pc;


const float AP_SLICE_COUNT = 32;
const float AP_KM_PER_SLICE = 4;


float AerialPerspectiveSliceToDepth(float slice) {
    return slice * AP_KM_PER_SLICE;
}


bool MoveToTopAtmosphere(inout vec3 WorldPos, vec3 WorldDir, float AtmosphereTopRadius) {
    float viewHeight = length(WorldPos);
    if (viewHeight > AtmosphereTopRadius)
    {
        float tTop = raySphereIntersectNearest(WorldPos, WorldDir, vec3(0.0, 0.0, 0.0), AtmosphereTopRadius);
        if (tTop >= 0.0)
        {
            vec3 UpVector = WorldPos / viewHeight;
            vec3 UpOffset = UpVector * -PLANET_RADIUS_OFFSET;
            WorldPos = WorldPos + WorldDir * tTop + UpOffset;
        }
        else
        {
            // Ray is not intersecting the atmosphere
            return false;
        }
    }
    return true; // ok to start tracing
}


vec4 gen_texel() {
    const int sliceId = int(gl_GlobalInvocationID.z);
    const vec2 pixPos = vec2(gl_GlobalInvocationID.xy) + vec2(0.5, 0.5);

    AtmosphereParameters Atmosphere = GetAtmosphereParameters();

    float gResolution = 32;
    vec3 ClipSpace = vec3((pixPos / vec2(gResolution))*vec2(2.0, 2.0) - vec2(1.0, 1.0), 0.5);
    vec4 HViewPos = u_pc.proj_inv * vec4(ClipSpace, 1.0);
    vec3 WorldDir = normalize(mat3(u_pc.view_inv) * (HViewPos.xyz / HViewPos.w));

    float earthR = Atmosphere.BottomRadius;
    vec3 earthO = vec3(0, -earthR, 0);
    vec3 camPos = u_pc.view_pos.xyz + vec3(0, earthR, 0);
    vec3 SunDir = u_pc.sun_direction.xyz;
    vec3 SunLuminance = vec3(0.0);

    float Slice = ((float(sliceId) + 0.5) / AP_SLICE_COUNT);
    Slice *= Slice;	// squared distribution
    Slice *= AP_SLICE_COUNT;

    vec3 WorldPos = camPos;
    float viewHeight;


    // Compute position from froxel information
    float tMax = AerialPerspectiveSliceToDepth(Slice);
    vec3 newWorldPos = WorldPos + tMax * WorldDir;


    // If the voxel is under the ground, make sure to offset it out on the ground.
    viewHeight = length(newWorldPos);
    if (viewHeight <= (Atmosphere.BottomRadius + PLANET_RADIUS_OFFSET))
    {
        // Apply a position offset to make sure no artefact are visible close to the earth boundaries for large voxel.
        newWorldPos = normalize(newWorldPos) * (Atmosphere.BottomRadius + PLANET_RADIUS_OFFSET + 0.001f);
        WorldDir = normalize(newWorldPos - camPos);
        tMax = length(newWorldPos - camPos);
    }
    float tMaxMax = tMax;


    // Move ray marching start up to top atmosphere.
    viewHeight = length(WorldPos);
    if (viewHeight >= Atmosphere.TopRadius)
    {
        vec3 prevWorlPos = WorldPos;
        if (!MoveToTopAtmosphere(WorldPos, WorldDir, Atmosphere.TopRadius))
        {
            // Ray is not intersecting the atmosphere
            return vec4(0.0, 0.0, 0.0, 1.0);
        }
        float LengthToAtmosphere = length(prevWorlPos - WorldPos);
        if (tMaxMax < LengthToAtmosphere)
        {
            // tMaxMax for this voxel is not within earth atmosphere
            return vec4(0.0, 0.0, 0.0, 1.0);
        }
        // Now world position has been moved to the atmosphere boundary: we need to reduce tMaxMax accordingly.
        tMaxMax = max(0.0, tMaxMax - LengthToAtmosphere);
    }

    const bool ground = false;
    const float SampleCountIni = max(1.0, float(sliceId + 1.0) * 2.0);
    const float DepthBufferValue = -1.0;
    const bool VariableSampleCount = false;
    const bool MieRayPhase = true;
    SingleScatteringResult ss = IntegrateScatteredLuminance(
        pixPos, WorldPos, WorldDir, SunDir, Atmosphere, ground, SampleCountIni,
        DepthBufferValue, VariableSampleCount, MieRayPhase, tMaxMax,
        u_trans_lut, u_multi_scat, vec2(32), u_pc.pv_inv
    );

    const float Transmittance = dot(ss.Transmittance, vec3(1.0 / 3.0));
    return vec4(ss.L, 1.0 - Transmittance);
}


void main() {
    imageStore(out_image, ivec3(gl_GlobalInvocationID.xyz), gen_texel());
}
